package usecase

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/TranThang-2804/infrastructure-engine/internal/domain"
	"github.com/TranThang-2804/infrastructure-engine/internal/shared/constant"
	"github.com/TranThang-2804/infrastructure-engine/internal/shared/env"
	"github.com/TranThang-2804/infrastructure-engine/internal/shared/log"
	"github.com/TranThang-2804/infrastructure-engine/internal/utils"
)

type compositeResourceUsecase struct {
	compositeResourceRepository     domain.CompositeResourceRepository
	compositeResourceEventPublisher domain.CompositeResourceEventPublisher
	bluePrintUsecase                domain.BluePrintUsecase
	iacPipelineUsecase              domain.IacPipelineUsecase
	contextTimeout                  time.Duration
}

func NewCompositeResourceUsecase(compositeResourceRepository domain.CompositeResourceRepository, compositeResourceEventPublisher domain.CompositeResourceEventPublisher, bluePrintUsecase domain.BluePrintUsecase, iacPiacPipelineUsecase domain.IacPipelineUsecase) domain.CompositeResourceUsecase {
	return &compositeResourceUsecase{
		compositeResourceRepository:     compositeResourceRepository,
		compositeResourceEventPublisher: compositeResourceEventPublisher,
		bluePrintUsecase:                bluePrintUsecase,
		iacPipelineUsecase:              iacPiacPipelineUsecase,
		contextTimeout:                  utils.GetContextTimeout(),
	}
}

func (cu *compositeResourceUsecase) GetAll(c context.Context) ([]domain.CompositeResource, error) {
	ctx, cancel := context.WithTimeout(c, cu.contextTimeout)
	defer cancel()
	return cu.compositeResourceRepository.GetAll(ctx)
}

func (cu *compositeResourceUsecase) Create(c context.Context, createCompositeResourceRequest domain.CreateCompositeResourceRequest) (domain.CompositeResource, error) {
	ctx, cancel := context.WithTimeout(c, cu.contextTimeout)
	logger := log.BaseLogger.FromCtx(ctx).WithFields("usecase", utils.GetStructName(cu))
	ctx = logger.WithCtx(ctx)

	defer cancel()

	// Validate BluePrintId
	bluePrint, err := cu.bluePrintUsecase.GetById(c, createCompositeResourceRequest.BluePrintId)
	if err != nil {
		logger.Error("Error getting blueprint by id", "error", err.Error())
		return domain.CompositeResource{}, err
	}

	var selectedBluePrintVersion domain.BluePrintVersion

	for _, version := range bluePrint.Versions {
		if version.Name == createCompositeResourceRequest.BluePrintVersion {
			selectedBluePrintVersion = version
		}
	}

	// Validate Spec With JsonSchema
	err = utils.ValidateJsonSchema(createCompositeResourceRequest.Spec, selectedBluePrintVersion.JsonSchema)
	if err != nil {
		logger.Error("Error validating json schema", "error", err.Error())
		return domain.CompositeResource{}, err
	}

	// Generate uuid
	logger.Debug("Generating uuidv7")
	uuid, err := utils.GenerateUUIDv7()
	if err != nil {
		logger.Error("Error getting all composite resources", "error", err.Error())
		return domain.CompositeResource{}, err
	}

	// Get current time
	currentTime := time.Now()
	currentDate := currentTime.Format("2006-01-02")

	// Getting user created
	createdBy := "anonymous"

	compositeResource := domain.CompositeResource{
		Name:             createCompositeResourceRequest.Name,
		Description:      createCompositeResourceRequest.Description,
		BluePrintId:      createCompositeResourceRequest.BluePrintId,
		BluePrintVersion: createCompositeResourceRequest.BluePrintVersion,
		Id:               uuid,
		CreatedAt:        currentDate,
		CreatedBy:        createdBy,
		LastModifiedAt:   currentDate,
		LastModifiedBy:   createdBy,
		Spec:             createCompositeResourceRequest.Spec,
		Status:           constant.Pending,
		Resources:        nil,
		Metadata:         createCompositeResourceRequest.MetaData,
	}

	// Generate resource template
	for _, template := range selectedBluePrintVersion.CompositeTemplate {
		selectedBluePrint, err := cu.bluePrintUsecase.GetByIdAndVersion(c, template.TemplateId, template.Version)
		if err != nil {
			logger.Error("Error getting blueprint by id", "error", err.Error())
			return domain.CompositeResource{}, err
		}

		resourceValue, err := utils.GenerateGoTemplateOutput(createCompositeResourceRequest.Spec, template.ValueTemplate)
		if err != nil {
			logger.Error("Error generating template", "error", err.Error())
			return domain.CompositeResource{}, err
		}

		resourceConfig := domain.Resource{
			Name:               selectedBluePrint.Name,
			Id:                 uuid,
			Status:             constant.Pending,
			Description:        "Generated by Infrastructure Engine using " + template.TemplateId,
			IacTemplateId:      template.TemplateId,
			IacTemplateVersion: template.Version,
			ResourceValue:      resourceValue,
			RunIds:             []domain.IacPipeline{},
		}

		compositeResource.Resources = append(compositeResource.Resources, resourceConfig)
	}

	// Store the composite resource
	compositeResourceCreated, err := cu.compositeResourceRepository.Create(ctx, compositeResource)

	if err != nil {
		logger.Error("Error creating composite resource", "error", err.Error())
		return domain.CompositeResource{}, err
	}
	logger.Debug("Created composite resource")

	// Push message to message queue to Provision
	err = cu.compositeResourceEventPublisher.PublishToPendingSubject(c, compositeResourceCreated)
	if err != nil {
		logger.Error("Error pushing message to queue", "error", err.Error())
		return domain.CompositeResource{}, err
	}

	return compositeResource, nil
}

func (cu *compositeResourceUsecase) Update(c context.Context, deleteCompositeResourceRequest domain.UpdateCompositeResourceRequest) (domain.CompositeResource, error) {
	return domain.CompositeResource{}, nil
}

func (cu *compositeResourceUsecase) Delete(c context.Context, deleteCompositeResourceRequest domain.DeleteCompositeResourceRequest) (domain.CompositeResource, error) {
	return domain.CompositeResource{}, nil
}

func (cu *compositeResourceUsecase) HandlePending(message []byte) error {
	logger := log.BaseLogger.WithFields("usecase", utils.GetStructName(cu))
	ctx := logger.WithCtx(context.Background())

	var compositeResource domain.CompositeResource

	ctx, cancel := context.WithTimeout(context.Background(), cu.contextTimeout)
	defer cancel()

	// Unmarshal the message into the composite resource struct
	err := json.Unmarshal(message, &compositeResource)
	if err != nil {
		logger.Error("Error unmarshalling message", "error", err.Error())
		return err
	}

	// Validate the composite resource
	err = utils.ValidateStruct(compositeResource)
	if err != nil {
		logger.Error("Error validating composite resource", "error", err.Error())
		return err
	}

	// Logic for handling the pending message
	for i := range compositeResource.Resources {
		currentResource := &compositeResource.Resources[i]
		newPipelineRun := domain.IacPipeline{
			Name:              currentResource.Name,
			Id:                len(currentResource.RunIds) + 1,
			Action:            "apply",
			GitProvider:       env.Env.CI,
			URL:               "",
			IacPipelineOutput: domain.IacPipelineOutput{},
		}

		// Trigger the pipeline to create the resource
		pipelineUrl, err := cu.iacPipelineUsecase.Trigger(ctx, newPipelineRun)
		if err != nil {
			logger.Error("Error triggering pipeline", "error", err.Error())
			return err
		}
		newPipelineRun.URL = pipelineUrl
		logger.Info("newPipelineRun", "pipeline", newPipelineRun)

		// Add the new pipeline run to the resource
		currentResource.RunIds = append(currentResource.RunIds, newPipelineRun)

		// Set resource status
		currentResource.Status = constant.Provisioning

		logger.Debug("Handled resource", "resource", currentResource)
	}

	// Save the new status
	compositeResource.Status = constant.Provisioning

	_, err = cu.compositeResourceRepository.Update(ctx, compositeResource)
	if err != nil {
		return err
	}

	// Publish the message to the provisioning subject
	cu.compositeResourceEventPublisher.PublishToProvisioningSubject(ctx, compositeResource)

	logger.Info("Handling pending message successful")
	return nil
}

func (cu *compositeResourceUsecase) HandleProvisioning(message []byte) error {
	logger := log.BaseLogger.WithFields("usecase", utils.GetStructName(cu))
	ctx := logger.WithCtx(context.Background())

	var compositeResource domain.CompositeResource

	logger.Debug("Start handling message provisioning")

	ctx, cancel := context.WithTimeout(context.Background(), cu.contextTimeout)

	defer cancel()

	// Unmarshal the message into the composite resource struct
	err := json.Unmarshal(message, &compositeResource)
	if err != nil {
		logger.Error("Error unmarshalling message", "error", err.Error())
		return err
	}

	// Validate the composite resource
	err = utils.ValidateStruct(compositeResource)
	if err != nil {
		logger.Error("Error validating composite resource", "error", err.Error())
		return err
	}

	// Logic for handling the pending message
	for i := range compositeResource.Resources {
		currentResource := &compositeResource.Resources[i]

		// Check if no pipeline exists -> mark resource as done
		if len(currentResource.RunIds) == 0 {
			currentResource.Status = constant.Done
		}

		currentPipeline := currentResource.RunIds[len(currentResource.RunIds)-1]

		pipelineStatus, err := cu.iacPipelineUsecase.GetPipelineStatus(ctx, currentPipeline)
		if err != nil {
			logger.Error("Error getting pipeline status", "error", err.Error())
			return err
		}

		switch pipelineStatus {
		case "Running":
			// If pipeline still in running -> skip this resource
			continue
		case "Success":
			// If pipeline success -> Mark resource as done and get output
			currentResource.Status = constant.Done

			// Getting pipeline output
			pipelineOutputByte, err := cu.iacPipelineUsecase.GetPipelineOutputByUrl(ctx, currentPipeline)
			if err != nil {
				logger.Error("Error getting pipeline output", "error", err)
				return fmt.Errorf("Error getting pipeline output: %s", err)
			}

			var pipelineOutput map[string]any
			err = json.Unmarshal(pipelineOutputByte, &pipelineOutput)
			if err != nil {
				logger.Error("Error unmarshalling pipeline output", "error", err)
				return fmt.Errorf("Error unmarshalling pipeline output: %s", err)
			}

			currentPipeline.IacPipelineOutput.OuputValue = pipelineOutput
			break
		case "Failed":
			// If pipeline success -> Mark resource as done and get output
			currentResource.Status = constant.Failed
			break
		default:
			logger.Error("Unknown pipeline status", "resource", currentResource, "pipeline status", pipelineStatus)
			break
		}
	}

	// Default status
	finalResourceStatus := constant.Done

	// Checking the composite resource status based on sub resources status
	for _, resource := range compositeResource.Resources {
		switch resource.Status {
		case constant.Done:
			// if this sub resource is done, continue
			continue
		case constant.Failed:
			// if one sub resource is failed, set the composite resource status to failed
			finalResourceStatus = constant.Failed
		case constant.Provisioning:
			// if one sub resource is provisioning, set the composite resource status to provisioning
			finalResourceStatus = constant.Provisioning
		}
	}

	compositeResource.Status = finalResourceStatus

	_, err = cu.compositeResourceRepository.Update(ctx, compositeResource)
	if err != nil {
		return err
	}

	// If composite resource is still in progress (not done or failed) -> send a new message to the provisioning subject
	if compositeResource.Status != constant.Done && compositeResource.Status != constant.Failed {
		if err = cu.compositeResourceEventPublisher.PublishToProvisioningSubjectWithDelay(ctx, compositeResource); err != nil {
			return err
		}
		return nil
	}

	logger.Info("Handle Provisioning Message Successful", "message", compositeResource.Status)
	return nil
}

func (cu *compositeResourceUsecase) HandleDeleting(message []byte) error {
	return nil
}
